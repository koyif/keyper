syntax = "proto3";

package keyper.api.v1;

option go_package = "github.com/koyif/keyper/pkg/api/proto;proto";

import "google/api/annotations.proto";
import "google/protobuf/timestamp.proto";
import "models.proto";
import "protoc-gen-openapiv2/options/annotations.proto";

// SecretsService handles CRUD operations for encrypted secrets.
//
// All secrets are encrypted client-side using AES-256-GCM before being sent to the server.
// The server stores only encrypted blobs and metadata, never having access to plaintext data.
// All endpoints require authentication via Bearer token in Authorization header.
service SecretsService {
  option (grpc.gateway.protoc_gen_openapiv2.options.openapiv2_tag) = {
    description: "CRUD operations for encrypted secrets. All endpoints require authentication. "
                 "Secrets are encrypted client-side using AES-256-GCM before upload."
  };
  // CreateSecret creates a new encrypted secret.
  //
  // The encrypted_data field should contain the AES-256-GCM encrypted payload,
  // base64-encoded. The encryption key is derived from the user's master password
  // on the client side and never sent to the server.
  //
  // Requires: Authorization header with valid access token.
  rpc CreateSecret(CreateSecretRequest) returns (CreateSecretResponse) {
    option (google.api.http) = {
      post: "/v1/secrets"
      body: "*"
    };
  }

  // GetSecret retrieves a specific secret by ID.
  //
  // Returns the encrypted secret data. Decryption must be performed client-side
  // using the encryption key derived from the user's master password.
  //
  // Requires: Authorization header with valid access token.
  rpc GetSecret(GetSecretRequest) returns (GetSecretResponse) {
    option (google.api.http) = {
      get: "/v1/secrets/{secret_id}"
    };
  }

  // UpdateSecret updates an existing secret.
  //
  // Uses optimistic locking via the version field to prevent concurrent modification conflicts.
  // If the version doesn't match the current server version, the update will fail.
  //
  // Requires: Authorization header with valid access token.
  rpc UpdateSecret(UpdateSecretRequest) returns (UpdateSecretResponse) {
    option (google.api.http) = {
      put: "/v1/secrets/{secret_id}"
      body: "*"
    };
  }

  // DeleteSecret soft-deletes a secret.
  //
  // Secrets are soft-deleted (marked as deleted but not removed from database)
  // to support synchronization with offline clients. Tombstone cleanup happens
  // automatically after 30 days.
  //
  // Requires: Authorization header with valid access token.
  rpc DeleteSecret(DeleteSecretRequest) returns (DeleteSecretResponse) {
    option (google.api.http) = {
      delete: "/v1/secrets/{secret_id}"
    };
  }

  // ListSecrets retrieves all secrets for the authenticated user.
  //
  // Supports filtering by type and category, with pagination for large result sets.
  // By default, soft-deleted secrets are excluded unless explicitly requested.
  //
  // Requires: Authorization header with valid access token.
  rpc ListSecrets(ListSecretsRequest) returns (ListSecretsResponse) {
    option (google.api.http) = {
      get: "/v1/secrets"
    };
  }

  // SearchSecrets searches secrets by title, tags, or category.
  //
  // Performs server-side search on unencrypted metadata fields only.
  // For searching encrypted content, decryption and search must be done client-side.
  //
  // Requires: Authorization header with valid access token.
  rpc SearchSecrets(SearchSecretsRequest) returns (SearchSecretsResponse) {
    option (google.api.http) = {
      get: "/v1/secrets/search"
    };
  }
}

// CreateSecretRequest contains data for creating a new secret
message CreateSecretRequest {
  SecretType type = 1;
  string title = 2;
  string encrypted_data = 3;  // Client-encrypted payload
  Metadata metadata = 4;
}

// CreateSecretResponse contains the created secret
message CreateSecretResponse {
  Secret secret = 1;
  string message = 2;
}

// GetSecretRequest contains the secret ID to retrieve
message GetSecretRequest {
  string secret_id = 1;
}

// GetSecretResponse contains the requested secret
message GetSecretResponse {
  Secret secret = 1;
}

// UpdateSecretRequest contains updated secret data
message UpdateSecretRequest {
  string secret_id = 1;
  string title = 2;
  string encrypted_data = 3;  // Client-encrypted payload
  Metadata metadata = 4;
  int64 version = 5;  // For optimistic locking
}

// UpdateSecretResponse contains the updated secret
message UpdateSecretResponse {
  Secret secret = 1;
  string message = 2;
}

// DeleteSecretRequest contains the secret ID to delete
message DeleteSecretRequest {
  string secret_id = 1;
}

// DeleteSecretResponse confirms deletion
message DeleteSecretResponse {
  string message = 1;
}

// ListSecretsRequest contains optional filtering parameters
message ListSecretsRequest {
  SecretType type = 1;  // Filter by type (optional)
  string category = 2;  // Filter by category (optional)
  bool include_deleted = 3;  // Include soft-deleted secrets
  int32 page_size = 4;  // Pagination
  string page_token = 5;  // Pagination token
}

// ListSecretsResponse contains the list of secrets
message ListSecretsResponse {
  repeated Secret secrets = 1;
  string next_page_token = 2;
  int32 total_count = 3;
}

// SearchSecretsRequest contains search criteria
message SearchSecretsRequest {
  string query = 1;  // Search term (searches title, tags, notes)
  SecretType type = 2;  // Filter by type (optional)
  string category = 3;  // Filter by category (optional)
  repeated string tags = 4;  // Filter by tags (optional)
  bool favorites_only = 5;  // Only return favorites
}

// SearchSecretsResponse contains matching secrets
message SearchSecretsResponse {
  repeated Secret secrets = 1;
  int32 total_count = 2;
}
